<!DOCTYPE html>
<html lang="en">
	<head>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.min.js"></script>
		<script src="https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"></script>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
		
		<title>Yuuoniy&#39;s blog</title>
		
		<meta name="description" content="LLVM IR 层介绍 前言 LLVM IR 是 LLVM 的中间语言，先前的文章包括了 IR 的简单介绍，本篇文章针对 IR深入学习。
包括以下内容：
  LLVM IR 特性
  IR 语法
  生成 IR
  格式 IR是SS A静态单一赋值的（Static Single Assignment）。
LLVM IR 是强类型语言。文档 LangRef
SSA “alloca &#43; mem2reg”技术
语法 结合例子分析语法，
首先编写程序
int sum(int a,int b){ return a&#43;b; } 编译转化为 LLVM IR
clang sum.c -emit-llvm -S -c -o sum.ll 得到 ll 文件：
$ cat sum.ll ; ModuleID = &#39;sum.">
		<meta name="author" content="">
		<meta name="generator" content="hugo-plains https://gitlab.com/hugo-plains/hugo-plains">
		
		<link href="https://yuuoniy.github.io/an-old-hope.min.css" rel="stylesheet">
		<link href="https://yuuoniy.github.io/style.css" rel="stylesheet">
		<link href="https://yuuoniy.github.io/custom.css" rel="stylesheet">
		
		<link rel="apple-touch-icon" href="https://yuuoniy.github.io/apple-touch-icon.png">
		<link rel="icon" href="https://yuuoniy.github.io/favicon.ico">
		
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.css">
		<meta name="generator" content="Hugo 0.76.5" />
		
		
		
		<script>
			function setTheme() {
				if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
					document.body.classList.add('dark');
					return;
				}
				
				let date = new Date();
				let time = date.getTime();
				let sunrise = date.setHours(7, 00); 
				let sunset = date.setHours(20, 00); 

				if (time < sunrise || time > sunset)
					document.body.classList.add('dark');
			}
			
		</script>
		
	</head>
	<body class="single">
		
		<script>
			setTheme();
			console.log("This site was made using Hugo and Plains. https://gohugo.io https://gitlab.com/hugo-plains/hugo-plains");
		</script>
		
		
		<header class="header">
			<nav class="nav">
				<p class="logo"><a href="https://yuuoniy.github.io/">Yuuoniy&#39;s blog</a></p>
				<ul class="menu">
					<li>
						<a href="/posts/">Posts</a>
					</li>
					<li>
						<a href="/tags/">Tags</a>
					</li>
					<li>
						<a href="/about/">About</a>
					</li>
					<li>
						<a href="/index.xml">RSS</a>
					</li>
				</ul>
			</nav>
		</header>
		<main class="main">


<article class="post-single">
	<header class="post-header">

		<h1 class="post-title"></h1>
		<div class="post-meta">January 1, 0001</div>
		
		
	</header>
	<div class="toc"></div><div class="post-content"><h1 id="llvm-ir-层介绍">LLVM IR 层介绍</h1>
<h2 id="前言">前言</h2>
<p>LLVM IR 是 LLVM 的中间语言，先前的文章包括了 IR 的简单介绍，本篇文章针对  IR深入学习。</p>
<p>包括以下内容：</p>
<ul>
<li>
<p>LLVM IR 特性</p>
</li>
<li>
<p>IR 语法</p>
</li>
<li>
<p>生成 IR</p>
</li>
</ul>
<h2 id="格式">格式</h2>
<p>IR是SS A静态单一赋值的（Static Single Assignment）。</p>
<p>LLVM IR 是强类型语言。文档 LangRef</p>
<h2 id="ssa">SSA</h2>
<p>“alloca + mem2reg”技术</p>
<h2 id="语法">语法</h2>
<p>结合例子分析语法，</p>
<p>首先编写程序</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">sum</span>(<span style="color:#66d9ef">int</span> a,<span style="color:#66d9ef">int</span> b){
	<span style="color:#66d9ef">return</span> a<span style="color:#f92672">+</span>b;
}
</code></pre></div><p>编译转化为 LLVM IR</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">clang sum.c <span style="color:#f92672">-</span>emit<span style="color:#f92672">-</span>llvm <span style="color:#f92672">-</span>S <span style="color:#f92672">-</span>c <span style="color:#f92672">-</span>o sum.ll
</code></pre></div><p>得到 ll 文件：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#960050;background-color:#1e0010">$</span> cat sum<span style="color:#f92672">.</span>ll
; ModuleID <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;sum.c&#39;</span>
source_filename <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;sum.c&#34;</span>
target datalayout <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128&#34;</span>
target triple <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;x86_64-unknown-linux-gnu&#34;</span>

; Function Attrs: noinline nounwind optnone uwtable
define dso_local i32 <span style="color:#a6e22e">@sum</span>(i32 <span style="color:#f92672">%</span><span style="color:#ae81ff">0</span>, i32 <span style="color:#f92672">%</span><span style="color:#ae81ff">1</span>) <span style="color:#75715e">#0 {</span>
  <span style="color:#f92672">%</span><span style="color:#ae81ff">3</span> <span style="color:#f92672">=</span> alloca i32, align <span style="color:#ae81ff">4</span>
  <span style="color:#f92672">%</span><span style="color:#ae81ff">4</span> <span style="color:#f92672">=</span> alloca i32, align <span style="color:#ae81ff">4</span>
  store i32 <span style="color:#f92672">%</span><span style="color:#ae81ff">0</span>, i32<span style="color:#f92672">*</span> <span style="color:#f92672">%</span><span style="color:#ae81ff">3</span>, align <span style="color:#ae81ff">4</span>
  store i32 <span style="color:#f92672">%</span><span style="color:#ae81ff">1</span>, i32<span style="color:#f92672">*</span> <span style="color:#f92672">%</span><span style="color:#ae81ff">4</span>, align <span style="color:#ae81ff">4</span>
  <span style="color:#f92672">%</span><span style="color:#ae81ff">5</span> <span style="color:#f92672">=</span> load i32, i32<span style="color:#f92672">*</span> <span style="color:#f92672">%</span><span style="color:#ae81ff">3</span>, align <span style="color:#ae81ff">4</span>
  <span style="color:#f92672">%</span><span style="color:#ae81ff">6</span> <span style="color:#f92672">=</span> load i32, i32<span style="color:#f92672">*</span> <span style="color:#f92672">%</span><span style="color:#ae81ff">4</span>, align <span style="color:#ae81ff">4</span>
  <span style="color:#f92672">%</span><span style="color:#ae81ff">7</span> <span style="color:#f92672">=</span> add nsw i32 <span style="color:#f92672">%</span><span style="color:#ae81ff">5</span>, <span style="color:#f92672">%</span><span style="color:#ae81ff">6</span>
  ret i32 <span style="color:#f92672">%</span><span style="color:#ae81ff">7</span>
}

attributes <span style="color:#75715e">#0 = { noinline nounwind optnone uwtable &#34;correctly-rounded-divide-sqrt-fp-math&#34;=&#34;false&#34; &#34;disable-tail-calls&#34;=&#34;false&#34; &#34;frame-pointer&#34;=&#34;all&#34; &#34;less-precise-fpmad&#34;=&#34;false&#34; &#34;min-legal-vector-width&#34;=&#34;0&#34; &#34;no-infs-fp-math&#34;=&#34;false&#34; &#34;no-jump-tables&#34;=&#34;false&#34; &#34;no-nans-fp-math&#34;=&#34;false&#34; &#34;no-signed-zeros-fp-math&#34;=&#34;false&#34; &#34;no-trapping-math&#34;=&#34;false&#34; &#34;stack-protector-buffer-size&#34;=&#34;8&#34; &#34;target-cpu&#34;=&#34;x86-64&#34; &#34;target-features&#34;=&#34;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&#34; &#34;unsafe-fp-math&#34;=&#34;false&#34; &#34;use-soft-float&#34;=&#34;false&#34; }</span>

<span style="color:#960050;background-color:#1e0010">!</span>llvm<span style="color:#f92672">.</span>module<span style="color:#f92672">.</span>flags <span style="color:#f92672">=</span> <span style="color:#960050;background-color:#1e0010">!</span>{<span style="color:#960050;background-color:#1e0010">!</span><span style="color:#ae81ff">0</span>}
<span style="color:#960050;background-color:#1e0010">!</span>llvm<span style="color:#f92672">.</span>ident <span style="color:#f92672">=</span> <span style="color:#960050;background-color:#1e0010">!</span>{<span style="color:#960050;background-color:#1e0010">!</span><span style="color:#ae81ff">1</span>}

<span style="color:#960050;background-color:#1e0010">!</span><span style="color:#ae81ff">0</span> <span style="color:#f92672">=</span> <span style="color:#960050;background-color:#1e0010">!</span>{i32 <span style="color:#ae81ff">1</span>, <span style="color:#960050;background-color:#1e0010">!</span><span style="color:#e6db74">&#34;wchar_size&#34;</span>, i32 <span style="color:#ae81ff">4</span>}
<span style="color:#960050;background-color:#1e0010">!</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">=</span> <span style="color:#960050;background-color:#1e0010">!</span>{<span style="color:#960050;background-color:#1e0010">!</span><span style="color:#e6db74">&#34;clang version 10.0.0 &#34;</span>}

</code></pre></div><p>下面结合该文件介绍语法</p>
<p>target datalayout: 第一字母表示端序。</p>
<p>以 type:<!-- raw HTML omitted -->:<!-- raw HTML omitted -->:<!-- raw HTML omitted --> 提供类型信息</p>
<p>attributes #0 表示使用</p>
<p>alloca 表示在栈上分配空间。通常会接一个对齐量。</p>
<pre><code>%a.addr 
</code></pre><p>最上方的 target datalayout 和 target triple 描述了目标机器的字节序、类型大小等信息，如指针位宽、首选对齐方式等。</p>
<p>nsw 是 no signed wrap 的缩写，类似的还有 nuw，no unsigned wrap，表示已知不会溢出，因此允许进行一些优化。</p>
<p>一些常用的指令</p>
<h4 id="转变指令">转变指令</h4>
<p>The ‘<code>bitcast</code>‘ instruction converts <code>value</code> to type <code>ty2</code> without changing any bits.</p>
<pre><code>&lt;result&gt; = bitcast &lt;ty&gt; &lt;value&gt; to &lt;ty2&gt;             ; yields ty2
</code></pre><p>icmp 指令</p>
<pre><code>&lt;result&gt; = icmp &lt;cond&gt; &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;   ; yields i1 or &lt;N x i1&gt;:result
</code></pre><h4 id="结束指令">结束指令</h4>
<p>br 指令</p>
<pre><code class="language-ir" data-lang="ir">br i1 &lt;cond&gt;, label &lt;iftrue&gt;, label &lt;iffalse&gt;
br label &lt;dest&gt;          ; Unconditional branch
</code></pre><p>The ‘<code>br</code>‘ instruction is used to cause control flow to transfer to a different basic block in the current function. There are two forms of this instruction, corresponding to a conditional branch and an unconditional branch.</p>
<h4 id="内存访问">内存访问</h4>
<h4 id="参数属性">参数属性</h4>
<pre><code>nocapture
</code></pre><p>This indicates that the callee does not make any copies of the pointer that outlive the callee itself. This is not a valid attribute for return values. Addresses used in volatile operations are considered to be captured.</p>
<pre><code>phi 
</code></pre><h4 id="函数属性">函数属性</h4>
<h2 id="aggregate-types">Aggregate Types</h2>
<p>IR的Aggregate Types包括数组和结构体。</p>
<h2 id="getelementptr">getelementptr</h2>
<p>我们可以使用 <code>getelementptr</code>指令来获得指向数组的元素和指向结构体成员的指针。</p>
<p>示例：</p>
<h2 id="布局">布局</h2>
<h3 id="llvm-ir-in-memory-model">LLVM IR in-memory model</h3>
<p>LLVM IR 的内存中表示模型与LLVM 语法模型相似， 相关类在 include/llvm/IR 下定义。下面介绍几个比较重要的类：</p>
<ul>
<li>Module 类</li>
</ul>
<p>可以通过 Module::iterator 遍历</p>
<ul>
<li>
<p>Functions 类</p>
<p>既可以表示函数声明也可以表示函数定义，</p>
</li>
</ul>
<p>通过 getArgumentList() 获取参数列表。也可以通过迭代器 Function::arg_iterator 的 arg_begin() 和 arg_end() 遍历。</p>
<p>如果 Function 对象为函数定义，那么通过 <code>for (Function::iterator i = function. begin(), e = function.end(); i != e; ++i)</code> 可以遍历基本块。</p>
<ul>
<li>
<p>BasicBlock 类</p>
<p>包含 LLVM 的指令序列，可以通过  begin()/end() 访问。通过 getTerminator() 接口可以直接访问基本块的最后一个指令。通过  getSinglePredecessor() 访问前继单个基本块。如果该基本块的predecessor不止一个，则需要自己手动获取 所有 predecessors。这可以通过遍历基本块并检查最后的指令实现。</p>
</li>
<li>
<p>Instruction 类</p>
</li>
</ul>
<p>表示 LLVM IR 的原子，单个指令。</p>
<p>他提供一些方法访问 high-level predicates ，如 isAssociative(), isCommutative(), isIdempotent(), or isTerminator() 。最主要的方法为 getOpcode()，返回 llvm::Instruction  枚举类，代表着 LLVM IR opcodes。可以通过  op_begin() 和  op_end() 访问。</p>
<p>下面介绍 LLVM IR 最强大的接口： Value 和 User 接口。通过他们可以方便浏览 use-def 和 def-use 链。</p>
<p>Value 子类通常代表一个结果，可以被其他对象使用。User 子类代表一个实体，其中包含了 Value 的接口。</p>
<p>Function 和Instruction 同时是 Value 和User的子类, BasicBlock 是 Value的子类。</p>
<p>下面详细介绍这两个类：</p>
<ul>
<li>
<p>Value 类：
定义了use_begin() 和 use_end() 方法，可以遍历Users获取 def-use 链。
每个 LLVM value 都有一个唯一的标识符，如 %add1 标识  add 指令的结果，BB1 代表一个基本块。myfunc 代表一个函数。 使用 getName() 接口获取名字；</p>
<p>方法replaceAllUsesWith(Value *) 可以对所有使用该 Value 的 users 替换为其他 Value。</p>
<p>这是SSA的一个优点，可以很方便地进行指令替换和速度优化。</p>
</li>
<li>
<p>User 类：
通过方法op_begin() 和 op_end()可以快速获取该 User 类使用的所有 Value 接口。这表示 use-def 链。可以使用 replaceUsesOfWith(Value *From, Value *To) 接口来替换该类使用的任意值。</p>
</li>
</ul>
<h1 id="编写自定义llvm-ir生成器">编写自定义LLVM IR生成器</h1>
<p>我们可以使用 LLVM IR 生成器 API 来构建 IR, 首先了解一下涉及的头文件。</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>#include &lt;llvm/ADT/SmallVector.h&gt;</td>
<td>可以使用 SmallVector&lt;&gt;  模板，帮助我们有效地构建数组。</td>
</tr>
<tr>
<td>#include &lt;llvm/Analysis/Verifier.h&gt;:</td>
<td>verifier  pass  用于检查LLVM module 是否遵循 IR rules。</td>
</tr>
<tr>
<td>#include &lt;llvm/IR/BasicBlock.h&gt;:</td>
<td>声明 BasicBlock  类</td>
</tr>
<tr>
<td>#include &lt;llvm/IR/CallingConv.h&gt;:</td>
<td>该文件包含一系列有关函数调用的 ABI，如在哪存储函数参数</td>
</tr>
<tr>
<td>#include &lt;llvm/IR/Function.h&gt;:</td>
<td>定义 Function 类</td>
</tr>
<tr>
<td>#include &lt;llvm/IR/Instructions.h&gt;:</td>
<td>声明了所有 Instruction  的子类。</td>
</tr>
<tr>
<td>#include &lt;llvm/IR/LLVMContext.h&gt;:</td>
<td>存储了 LLVM 库 的全局数据，允许多线程实现。</td>
</tr>
<tr>
<td>#include &lt;llvm/IR/Module.h&gt;:</td>
<td>声明 Module  类</td>
</tr>
<tr>
<td>#include &lt;llvm/Bitcode/ReaderWriter.h&gt;:</td>
<td>允许读写 LLVM bitcode 文件</td>
</tr>
<tr>
<td>#include &lt;llvm/Support/ToolOutputFile.h&gt;:</td>
<td>声明了用于写入到文件的工具类</td>
</tr>
</tbody>
</table>
<p>关于 LLVM 接口/数据结构等更多介绍可以查看文档 <a href="http://llvm.org/docs/ProgrammersManual.html">http://llvm.org/docs/ProgrammersManual.html</a></p>
<h3 id="参考资料">参考资料</h3>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/66793637">A Tour to LLVM IR (上)</a></li>
<li><a href="http://blog.wangluyuan.cc/2020/03/28/intro-to-llvm-ir/">Intro to LLVM IR</a></li>
<li><a href="https://www.ibm.com/developerworks/opensource/library/os-createcompilerllvm1/index.html">Create a working compiler with the LLVM framework, Part 1</a></li>
<li><a href="http://llvm.org/docs/ProgrammersManual.html">http://llvm.org/docs/ProgrammersManual.html</a></li>
<li><a href="https://segmentfault.com/p/1210000009435800/read">https://segmentfault.com/p/1210000009435800/read</a></li>
<li><a href="https://llvm-tutorial-cn.readthedocs.io/en/latest/">https://llvm-tutorial-cn.readthedocs.io/en/latest/</a></li>
<li><a href="https://blog.csdn.net/qq_29674357/article/details/78731713">https://blog.csdn.net/qq_29674357/article/details/78731713</a></li>
<li><a href="https://readthedocs.org/projects/mapping-high-level-constructs-to-llvm-ir/downloads/pdf/latest/">https://readthedocs.org/projects/mapping-high-level-constructs-to-llvm-ir/downloads/pdf/latest/</a></li>
</ol>
</div>
	<script>
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		function mashiroToc(mashiro) {
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    if (mashiro) {
        var id = 1;
        $(".post-content").children("h1,h2,h3,h4,h5").each(function() {
            
            var hyphenated = "mm-" + id;
            $(this).attr('id', hyphenated);
            id++;
        });
        
        tocbot.init({
            tocSelector: '.toc',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            positionFixedSelector: ".toc",
            scrollEndCallback: function (e) {
                window.scrollTo(window.scrollX, window.scrollY - 80);
            },
        });
    }
}
	mashiroToc(true);
	</script>
	
</article></main>
<footer class="footer">
	<span>
		Copyright © 2020–2020, Yuuoniy and the Hugo Authors; all rights reserved.
		
	</span>
	<span>&middot;</span>
	<span>Powered by <a href="https://gohugo.io/" rel="noopener" target="_blank">Hugo️️</a>️ and <a href="https://gitlab.com/hugo-plains/hugo-plains" rel="noopener" target="_blank">Plains</a></span>
</footer>
<script src="https://yuuoniy.github.io/highlight.min.js"></script>
<script>
	hljs.initHighlightingOnLoad();
</script>
</body>
</html>
